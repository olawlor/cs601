<!DOCTYPE html>
<html>
<title>BRISC: Bootstrapped RISC</title>
<script type="text/javascript">

/*
 BRISC simulator version 0.25
 
 Documentation and design:
   https://docs.google.com/document/d/1B_NUGbx8rkn--eyWLqDGa5xa54LQasdEC4kmj0SAzBc/edit?tab=t.0
 
 by Dr. Orion Lawlor and the CS 601 class, 2026-02-12 (Public Domain)
*/
var memory = []; // <- set dynamically below

/* Memory addresses used by hardware */
var opcode_table_start = 0xC00; // address of 256 opcode handlers!

/* Memory addresses used by software */
var decode_area_start = 0xD00; // decode frames
var decode_frame_size = 0x20; // bytes per decode frame
var handler_code_start = 0xE00; // machine code for instruction handlers
var stack_pointer_start = 0xFAF0; // runtime stack (rA) initial value


// Registers: store 32-bit values (for now, due to JavaScript limitations)
var r = [
  0,0,0,0,
  0,0,0,0,
  0,0,0,0,
  0,0,0,0
];

// Fail function
function sanity_fail(str,num) {
    var err = "Runtime sanity fail: "+str+" ("+num+")";
    console.log(err);
    document.getElementById("error").innerHTML=err;
    throw(str);
}


// Input: unsigned 8-bit value.
//  Output: int sign extended from that.
function sign_extend8(IN)
{
    if (IN & (1<<7)) { // sign bit set, it's negative
        IN = IN - (1<<8);
    }
    return IN;
}

// Input: unsigned 12-bit value.
//  Output: int sign extended from that.
function sign_extend12(ccc)
{
    if (ccc & (1<<11)) { // sign bit set: sign extend
        //ccc = -(ccc & 0x7FF); // pull low 11 bits (1's comp!)
        //       remove sign   make negative
        ccc = ccc - (1<<11) - (1<<11); // 2's complement
    }
    return ccc;
}

// Input: 64-bit register value
//   BUG: 32 bits due to JS
//   Output: bit rotated that far
function rotate_right(val,dist)
{
    dist = dist & 63; // wrap shift count to 0..63 (handling negatives correctly)
    return (val>>dist)|(val<<(64-dist));
}

// Swap register values
function swap(d,a) 
{
    //swap(r[d],r[a]);
    var old = r[d];
    r[d]=r[a];
    r[a]=old;
}

// Bitwise nand helper
function nand(a,b) {
    return ~(a&b);
}

// Bitwise conditional NOT: 
function cnot(val,flip) {
    if (flip==0) return val;
    else return ~val;
}

// Make an address from register value and some constants
function address(regval, b, IN)
{
    if (b!=0) sanity_fail("Bad buffer ID b!",b);
    return regval + IN;
}

function memory_write(address,value) {
    memory[address] = value;
}

function memory_op(M, d, address)
{
/*
    var register_window_addr = 0xFF00;
    // Probably a bad idea for hardware: put registers into memory in this window
    if (address>=register_window_addr && address<16+register_window_addr) 
    {
        var i = address - register_window_addr;
        switch(M) {
        case 0: // memory read
            r[d] = r[i];
            break;
        case 1: // memory write
            r[i] = r[d];
            break;
        case 2: // memory swap
            var old = r[d];
            r[d]=r[i];
            r[i]=old;
            break;
        default:
            sanity_fail("Bad register window memory op M = ",M);
        }
    }
    else 
*/
    { // just normal memory address
        switch(M) {
        case 0: // memory read
            r[d] = memory[address]|0; //<- reads uninit. mem as 0
            break;
        case 1: // memory write
            //memory[address] = r[d];
            memory_write(address, r[d]);
            break;
        case 2: // memory swap
            var old = r[d];
            r[d]=memory[address]|0;
            memory[address]=old;
            break;
        default:
            sanity_fail("Bad memory op M = ",M);
        }
    }
}


// Execute a 32-bit int as a BRISC instruction:
function exec_inst(inst)
{
    // Decode instruction
    var op = (inst >> 24) & 0xff; // 8-bit opcode
    var d = (inst >> 20) & 0xf; // 4-bit register num
    var a = (inst >> 16) & 0xf; // 4-bit register num
    var b = (inst >> 12) & 0xf; // 4-bit register num
    var ccc = sign_extend12((inst >> 0) & 0xfff); // 12-bit const field
    var M = (inst >> 8) & 0xf; // 4-bit const field
    var I = (inst >> 4) & 0xf; // 4-bit const field
    var N = (inst >> 0) & 0xf; // 4-bit const field
    var IN = sign_extend8((inst >> 0) & 0xff); // 8-bit const field
    
    if (d==0) sanity_fail("Can't write to reg 0! inst = ",inst);
    
    switch(op) {
    case 0x0A: // Add opcode
        r[d] = r[a] + r[b] + ccc;
        break;
    case 0x0B: // Bitwise rotate
        r[d] = rotate_right(r[a], r[b] + ccc);
        break;
    case 0x0C: // Conditional swap
        if (r[b]>=ccc) swap(d,a);
        break;
    case 0x0D: // bitwise nanD
        r[d] = cnot(nand(cnot(r[a],I),cnot(r[b],N)),M); 
        break;
    case 0x0E: // mEmory
        memory_op(M, d, address(r[a],b,IN));
        break;
    /*
    case 0x0F: // Freaky indirect register write: this path was not chosen
        r[r[a]]=r[1];
        break;
    */
    default:
        // Decode a higher-level operation: 
        //  - Stash registers in a "decode frame" relative to rD
        //  - Stash decode information
        //  - Find instruction handler and run it
        //  - Handler will end with cleanup code
        // (This could all be done in level 0 code, except saving r[0xF])
        
        r[0xD] += decode_frame_size; // shift destination window (allows level 2 -> 1 -> 0)
        var rD = r[0xD]; // address of our decode frame
        
        // Save the instruction we're decoding up top, so we know what we're doing
        memory_write(rD + 0x0, inst); /// all instruction bits
        
        // Save all registers, so we can restore them all 
        //  (Critically, this stores r[0xF] for resuming after this instruction)
        for (var c = 1; c<16; c++) memory_write(rD + c, r[c]);
        
        // Save instruction decoded stuff (possibly redundant for most instructions)
        //  rD + 0x10..0x1F: decoded instruction parts (mostly convenience)
        memory_write(rD + 0x11, op);
        memory_write(rD + 0x12, d);
        memory_write(rD + 0x13, a);
        memory_write(rD + 0x14, b);
        memory_write(rD + 0x15, M);
        memory_write(rD + 0x16, I);
        memory_write(rD + 0x17, N);
        memory_write(rD + 0x18, ccc);
        memory_write(rD + 0x19, IN);
        // Future expansion space here!
        
        // Set up registers so the handler works like a function call:
        //  r1 = r[d], r2 = r[a], r3 = r[b], r4=ccc
        //  rE = address of cleanup code that writes back r[d] and restores registers
        //  (Copies using array destructuring to avoid trashing e.g., r1 before it's used.
        [ r[1], r[2], r[3], r[4] ] = [r[d], r[a], r[b], ccc];
        
        r[0xE] = handler_code_start; // cleanup code is here
        
        // Look up this opcode handler code in our table of opcode handlers:
        var handler = memory[opcode_table_start + op]|0;
        if (handler==0) sanity_fail("Bad opcode ",op);
        r[0xF] = handler;
        
        break;
    }
}

// Execute one step.  Returns true if the program is still running.
function exec_step() {
    var fetch = r[0xF]; // address to fetch from

    var inst = memory[fetch];
    if (inst===undefined) sanity_fail("Fetch address invalid, rF =",fetch);
    
    console.log("fetched ",inst.toString(16)," from ",fetch.toString(16));
    r[0xF]++; // move program counter forward
    exec_inst(inst);
    return true;
}

// Execute n steps.  Returns true if the program is still running.
function exec_n(n) {
    while (n-- > 0) {
        if (!exec_step()) return false;
    }
    return true;
}



// Reset the regs and program counter for startup
function exec_reset() {
    // Reset register values array
    r = [
      0,0,0,0,
      0,0,0,0,
      0,0,0,0,
      0,0,0,0
    ];
    r[0xA]=stack_pointer_start; // stack pointer start value
    r[0xD]=decode_area_start; // instruction level decode stack 
    r[0xF]=0; // start running code at address 0
    
    memory = []; // clear mem
    level1setup();
}

/**************
BRISC Assembler!   Use these like:
   with (BRISC) {
       memcpy(0xF00, [
            set(r3,123),
            add(r1,r3,0,5),
            jmp(rE),
       ]);
   }
*/
// Add handy register names, like rA.  
//   Implemented as bare ints, so rF = 0xF
var BRISC={};
for (var c=0;c<16;c++) {
    BRISC[num2id(c)]=c;
}

// Utility function to copy a block of memory to this target address.
//   Returns the address beyond the end of the copy (ready for the next copy).
BRISC.memcpy = function(targetAddr, srcArray)
{
    var len = srcArray.length;
    for (var i = 0;i<len;i++) memory[targetAddr+i] = srcArray[i];
    return targetAddr+len; // one past the end
}


/*
  Input: int opcode and parameters for an instruction
  Output: int machine code for that operation
*/
BRISC.asm = function(opcode,d,a,b,ccc)
{
    var inst=0;
    if (ccc>=(1<<11) || ccc<-(1<<11))
        sanity_fail("set value too big: ",value);
    if (d==0)
        sanity_fail("can't assemble d=0 in opcode ",opcode);
    
    inst = (opcode<<24) | (d<<20) | (a<<16) | (b<<12) | (ccc & 0xfff); 
    
    return inst;
}

// Instruction definitions use BRISC stuff:
with (BRISC) {

    // Load a constant into a register
    BRISC.set = function(dest,value)
    {
        return asm(0x0A,dest,0,0,value);
    }

    // Copy one register into another
    BRISC.mov = function(dest,src)
    {
        return asm(0x0A,dest,src,0,0);
    }

    // Random memory operation M
    BRISC.memoryOp = function(valueReg, addressReg, addressConst, M)
    {
        if (addressConst>=(1<<7) || addressConst<-(1<<7))
            sanity_fail("address constant too big: ",value);
        return asm(0x0E,valueReg,addressReg,0,((M<<8)|(0xFF&addressConst)));
    }

    // Write to memory at this address
    BRISC.write = function(valueReg, addressReg, addressConst=0)
    {
        return memoryOp(valueReg,addressReg,addressConst,1);
    }
    // Read from memory at this address
    BRISC.read = function(valueReg, addressReg, addressConst=0)
    {
        return memoryOp(valueReg,addressReg,addressConst,0);
    }
    // Swap this register with memory at this address
    BRISC.swapmem = function(valueReg, addressReg, addressConst=0)
    {
        return memoryOp(valueReg,addressReg,addressConst,2);
    }

    // Conditional register swap: swap r[d] and r[a] if r[b]>=ccc
    BRISC.swapcond = function(d, a, b, ccc)
    {
        return asm(0x0C,d,a,b,ccc);
    }

    // General add two registers and a constant (positive or negative, gets sign extended)
    BRISC.add = function(d, a, b, ccc=0)
    {
        return asm(0x0A,d,a,b,ccc);
    }
    // Increment a register
    BRISC.inc = function(d, ccc=1)
    {
        return asm(0x0A,d,d,0,ccc);
    }
    // Decrement a register
    BRISC.dec = function(d, ccc=-1)
    {
        return asm(0x0A,d,d,0,ccc);
    }

    // Jump to line ccc
    BRISC.jump = function(ccc) {
        return set(0xF,ccc);
    }

    // Jump to register t
    BRISC.jumpreg = function(t) {
        return mov(0xF,t);
    }

    // Call a function pointed to by rE
    BRISC.callE = function() {
        return asm(0x0C,0xF,0xE,0,0);
    }
    // Return (to rE)
    BRISC.ret = function ret() {
        return asm(0x0C,0xE,0xF,0,0);
    }
    
    

}; // end with(BRISC)

// Level 1 instruction decoder setup:
function level1setup() {
    var codeAddr = handler_code_start; // address of level 0 code we're adding
    with(BRISC) {
        // First thing is the cleanup handler:
        codeAddr = memcpy(codeAddr, [
            // copy r1 to destination register
            read(r2,rD,0x12), // d in decode frame
            add(r2,r2,rD,0), // r2 = addess of target register
            write(r1,r2), // write value in r1 to target register
            
            // restore all the registers, except rD and rF
            //   (really only needs both [d] and any trashed registers, but all is easier!)
            read(r1,rD,0x1),
            read(r2,rD,0x2),
            read(r3,rD,0x3),
            read(r4,rD,0x4),
            read(r5,rD,0x5),
            read(r6,rD,0x6),
            read(r7,rD,0x7),
            read(r8,rD,0x8),
            read(r9,rD,0x9),
            read(rA,rD,0xA),
            read(rB,rD,0xB),
            read(rC,rD,0xC),
            read(rE,rD,0xE),
            
            // move rD back by one decode frame (add negative)
            add(rD,rD,r0,-decode_frame_size),
            
            // restore rF (from our original frame!)
            read(rF,rD,0xF+decode_frame_size)
        ]);
        
        
        // Push instruction: 0x1AAn0000: push register n to the stack (A)
        memory[opcode_table_start + 0x1A] = codeAddr;
        codeAddr = memcpy(codeAddr, [
            dec(r1), // make space at stack pointer
            write(r2,r1), // push [a] to stack memory
            
            jumpreg(rE) // go to cleanup handler
        ]);
        // Pop instruction: 0x1BAn0000: pop into register n from the stack (A)
        memory[opcode_table_start + 0x1B] = codeAddr;
        codeAddr = memcpy(codeAddr, [
            read(r2,r1), // read [d] from stack pointer
            inc(r1), // clean up space at stack pointer
            
            // Special: pop writes to a, so update that register
            read(r3,rD,0x13), // load a (to change r[a])
            add(r3,r3,rD,0), // calc address of saved r[a]
            write(r2,r3), // update saved [a]
            
            jumpreg(rE) // go to cleanup handler
        ]);
        // Level 2 example: 0x2Anm0000  push m and then pop into n
        memory[opcode_table_start + 0x2A] = codeAddr;
        codeAddr = memcpy(codeAddr, [
            0x1AA20000, // push r2 (m)
            0x1BA10000, // pop r1 (n)
            
            jumpreg(rE) // go to cleanup handler
        ]);
        

        // CJ's amazing subtract instruction: dynamically build instruction at runtime (!)
        memory[opcode_table_start + 0xC4] = codeAddr;
        codeAddr = memcpy(codeAddr, [
            set(r1, 0x0FF), // r1 = 0xFF    Build bitmasks for the instruction pieces we need
            0x0B110018, // r1 = 0x00000FF00
            add(r1, r1, r0, 0x0F), // r1 = 0x00000FF0F
            0x0B110018, // r1 = 0x000FF0F00
            add(r1, r1, r0, 0x0FF), // r1 = 0x00FF0FFF
            0x0E2D0000, // r2 = inst (0xC4dabmin)
            0x0D112100, // r1 = r1 & r2, 0x00da0min
            0x0E2D0012, // r2 = d
            0x0B22000C, // r2 = 0x00d00000
            add(r2, r2, 0, 0x0A), // r2 = 0x00d0000A
            0x0B220008, // r2 = 0x0A00d000
            add(r3, r1, r2), // r3 = 0x0Adadmin
            0x0E3F0112, // overwrite @TODO3 instruction
            set(r1, 1),
            0x0E1D0012, // r1 = d
            0x0B11000C, // r1 = 0x00d00000
            add(r2, r1, r2, 1), // r2 = 0x0Ad0d001
            0x0E2F010C, // overwrite @TODO2
            0x0E1D0012, // r1 = d
            add(r1, r1, r0, 0x0D0), // 0x000000Dd
            0x0B11001C, // r1 = 0x00000Dd0
            0x0E2D0014, // r2 = b
            add(r1, r1, r2, 0), // r1 = 0x00000Ddb
            0x0B110010, // r1 = 0x0Ddb0000
            add(r1, r1, r0, 1), // 0x0Ddb0001
            0x0E1F0103, // overwrite @TODO1
            0x0E1D0001, // restore r1
            0x0E2D0002, // restore r2
            0x0E3D0003, // restore r3
            0x00000000, // r[d] = ~r[b] : TODO1
            0x00000000, // r[d] = r[b] + 1 : TODO2
            0x00000000, // 0x0Adadmin, placeholder, overwritten : TODO3
            0x0EFD000F, // restore rF
        ]);
    }
}






/*
All the display and UI code is just inline, pure JavaScript.
*/
var ncols=16; // register count
var nrows=1; // rows of output data
var table=null;
var outRegs={}; // hash storing DOM table entry for registers

// UI change detection:
var UIr=[]; // will be copied from r in setup
var UImem=[]; 

// Colors for register values
var onColor = "#883333"; // desaturated red, like glowing LED
var doneColor = "#cccccc"; // light gray for done
var blankColor = "#000000"; // background color for off

// Convert a number to hexadecimal, using at least this many places.
function toHex(number,places=2) {
    // return number.toString(16).toUpperCase(); // no size specified

    var ret = "";
    while (places-- > 0 || number > 0) {
        var digit = number&0xF;
        var c = "0123456789ABCDEF"[digit];
        ret = c + ret;
        number = number>>>4; // subtle: unsigned right shift
    }
    return ret;
}

// num2id: make a register number into a human-readable string, or DOM id
//   Example: num2id(15) = "rF"
function num2id(c) {
    return "r" + c.toString(16).toUpperCase(); // hex reg name
}


// Fill memory from the UI code
function UIsetup() {
	var code=document.getElementById("code").value;
    var errDOM=document.getElementById("error");
	
	// Add code to stash user's code into memory
	with (BRISC) {
	    var fullCode = "var codememory = [ \n\n "+code+" \n\n ]; ";
	    errDOM.innerHTML="";
	    try {
	        eval(fullCode);
	        memcpy(0,codememory);
	    }
	    catch (syntaxError) {
	        errDOM.innerHTML = "Setup error: "+syntaxError+" from <pre>"+fullCode+"</pre>";
	        rarr=[];
	    }
	}
	
	// Spread syntax for array copies
	UIr=[];
    UImem=[]; 
    for (var c=0;c<ncols;c++)
    {        
        outRegs[c].style.backgroundColor = blankColor;
        outRegs[c].innerHTML = "0";
	}
}


// Dump memory from this address to this DOM div
function UIshowmem(string, startAddr, nonzero,div)
{
    var len=0x20;
    var dump = ""; // text to dump to screen
    if (nonzero && startAddr==0) len=0;
    else {
        // Make simple ascii table:
        dump+=string+":\n";
        // "memory from 0x"+toHex(start)+":\n";
        for (var addri=0;addri<0x20;addri++) {
            var addr = startAddr + addri;
            var now = memory[addr]|0;
            var old = UImem[addr]|0;
            var note="";
            if (now!==old) { // memory value changed
                UImem[addr]=now;
                note=" !"+note; 
            }
            
            if (addr==r[0xF]) { // we're over the fetch address
                note=note+" <-rF";
            }
            if (addr==r[0xE] && addr!=0) { // we're over the link address
                note=note+" <-rE";
            }
            if (addr==r[0xD] && addr!=0) { // we're over the decode address
                note=note+" <-rD";
            }
            if (addr==r[0xA] && addr!=0) { // we're over the stack pointer address
                note=note+" <-rA";
            }
        
            dump+=toHex(addr,2)+": "+toHex(now,8)+note+"\n";
        }
    }
    div.innerHTML="<pre>"+dump+"</pre>";
}


// Update the register and memory dumps
function UIupdate(running) {
    //console.log("UIupdate(",running,")");
    
	// Register updates
    for (var c=0;c<ncols;c++)
    {
        var color = blankColor;
        if (UIr[c] !== r[c]) { // value changed!
            color = onColor;
            if (!running) color = doneColor;
            var v = r[c]|0; // number
            var str = v.toString();
            if (v!=0) str += "<br>0x"+toHex(v);
            outRegs[c].innerHTML = str;
        }
        UIr[c] = r[c]; // always update (overwrites undefined too)
        
        // (subtle: always update color, so they reset)
        //console.log("  setting ",c," to ",color);
        outRegs[c].style.backgroundColor = color;
    }
    
    // Memory dumps: always show low memory
    UIshowmem("Low memory",0,0,document.getElementById("memdump1"));
    
    // Show area around rF (program counter)
    var rFseg = r[0xF]&~0x1F; // round down to "segment" start
    UIshowmem("Code",rFseg,1,document.getElementById("memdump2"));
    
    // Show area around rD (decode pointer)
    var rDseg = r[0xD]&~0x1F; // round down to "segment" start
    UIshowmem("Decode",rDseg,1,document.getElementById("memdump3"));
    
    // Show area around rA (stack pointer)
    var rAseg = r[0xA]&~0x1F; // round down to "segment" start
    UIshowmem("Stack",rAseg,1,document.getElementById("memdump4"));
}

// Button entry points
function buttonLoad() {
    exec_reset();
    UIsetup();
    UIupdate(true);
}

// Run silently for n sim steps (no UI update)
//   Returns true if we're still OK and running.
function runSilent(n) {
    var running = false;
    try {
        exec_n(n);
        running=true;
    } catch(e) {
        console.log(e);
        console.trace();
    }
    return running;
}

// Run the CPU for n sim steps, including UI update
function runFor(n) {
    UIupdate(runSilent(n));
}

// Run the CPU for n top-level steps, not part of a decode.
function topRunFor(n) {
    var running=true;
    var decode_start = r[0xD]; // height of decode stack when we started here
    
    for (var i=0;i<n && running;i++) {
        var done_decode = true;
        do {
            running=runSilent(1);
            done_decode = (r[0xD]==decode_start);
        } while(!done_decode && running);
        
        // Always skip over the decode cleanup
        //   (that last jump runs after resetting r[0xD])
        while (running && (r[0xF]>=0xE00 && r[0xF]<=0xE11)) running=runSilent(1);
    }
    UIupdate(running);
}


// (What happens when we update the form?)
function formUpdate() {
}

function startupCode() {
    // Make the the output table:
	table=document.getElementById("output");
	
	var src="<table border=1>\n";
	for (var r=-1;r<nrows;r++)
	{
	    src+="<tr>\n";
	    
	    for (var c=0;c<ncols;c++)
	    {
	        var desc = null;
	        var id = null;
	        var reg = num2id(c);
	        if (r<0) { // title row
	            desc = reg;
	        }
	        else { // values displayed here
	            id = reg;
           }
           
           if (id) {
                src+="<td id='"+id+"' width=32 height=32 />\n";
           }
           else {
                src+="<td align='center'>";
                if (desc) {
                    src+=desc;
                }
                src+="</td>\n";
           }
	    }
	    src+="</tr>\n";
	}
	src+="</table>\n";
	table.innerHTML=src;
	
	// Look up the table's DOM elements
	for (var r=0;r<nrows;r++)
	{
	    for (var c=0;c<ncols;c++)
	    {
	        outRegs[c]=document.getElementById(num2id(c));
	    }
	}
	
	// Pull CGI-bin parameters for code import, like sim0.html?code=0xf00c0de
	try {
    	var params = new URLSearchParams(window.location.search);
    	var code = params.get('code');
    	if (code && code!="") {
    	    document.getElementById("code").value = code;
    	    runCode();
    	}
	}
	catch (e) {}
	
    console.log("Startup code finished");
}

</script>
<style>
body {
    background-color: #000000;
    color: #ccffcc;
}
textarea {
    color: #ccffcc;
}
:root {
	color-scheme: dark;
}
</style>

</head>
<body onload="startupCode()"  >
<h1>BRISC: Bootstrapped RISC</h1>
<form method="post" action="javascript:formUpdate()" enctype="multipart/form-data">
<table style="background:#222222"><tbody>
<tr>
 <td>
  <button id="LoadButton" onclick="buttonLoad();" title="Load the machine's memory and reset the registers" >LOAD</button>
   <button id="StepButton" onclick="topRunFor(1);" title="Run the machine for a single top-level step" >Step Over</button>
   <button id="StepButton" onclick="runFor(1);" title="Run the machine for a single sim step" >Step In</button>
   <button id="Step4Button" onclick="runFor(4);" title="Run the machine for 4 sim steps" >Step by 4</button>
   <button id="Step16Button" onclick="runFor(16);" title="Run the machine for 16 sim steps" >Step by 16</button>
   <button id="Run" onclick="runFor(256);" title="Run the machine for 256 sim steps" >Run</button>
 </td>
</tr>
<tr>
 <td width="50%" valign="top">
   <div id="output">
 </td>
</tr>
<tr>
 <td width="50%" valign="top">
<div id="error" style="background:#ff7777;"></div>

BRISC machine code:<br>

<table><tr>
<td>
<!-- clunky way to do line numbers -->
<textarea id="lineno" name="lineno" rows="35" cols="4" spellcheck="false" style="text-align: right; color:#888; ">
rF
0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
0x10
0x11
0x12
0x13
0x14
0x15
0x16
0x17
0x18
0x19
0x1A
0x1B
0x1C
0x1D
0x1E
0x1F

</textarea>
</td>
<td>
<textarea id="code" name="code" rows="35" cols="60" spellcheck="false">
//  0xopdabmin:
    set(r4, 0x555),  // load 555 into r4
    0x2A540000, // level 2: push r4, pop into r5
    set(r7, 9), // address of end of loop
    set(r8, 0), // loop counter starts at 0
    set(r9, 0), // total starts at 0
        inc(r9,10), // LOOP: r9 += 10
        inc(r8), // r8++
        swapcond(rF,r7, r8,5), // if counter>=5 goto end
        jump(5), // <- FIXME if loopstart changes!
    set(rE, 0x0C),  // FIXME rE = (address to call)
    callE(),  // call function at rE
    set(r6,99), // demo return from function below
    0x0B140008,  // bit rotate r4 by 8 into r1
        write(r4, 0, 0x19),  // FUNCTION: write r4 to mem
        ret(),  // return to rE

// Other examples:
    0x1AA40000, // level 1 test: push r4
    0x1BA50000, // level 1 test: pop into r5
</textarea>
<!--


//  0xopdabmin:
    0x0A400555,  // load 555 into r4
    0x0AE00004,  // rE = 4 (address to call)
    0x0CFE0000,  // call function at rE
    0x0B140008,  // bit rotate r4 by 8 into r1
    0x0E400109,  // write r4 to address 9
    0x0CEF0000,  // return to rE


-->
</td>
<td valign="top">
    <div id="memdump1" />
</td>
<td valign="top">
    <div id="memdump2" />
</td>
<td valign="top">
    <div id="memdump3" />
</td>
<td valign="top">
    <div id="memdump4" />
</td>
</tr> </table>

 </td>
</tr>
</table>
</form>
<p>Directions: (1) write machine code in <a href="https://docs.google.com/document/d/1B_NUGbx8rkn--eyWLqDGa5xa54LQasdEC4kmj0SAzBc/edit?tab=t.0">Bootstrapped RISC (BRISC) format</a>.  (2) LOAD the code.  (3) Step through it and see the results!

<p align="right"><i>by <a href="mailto:lawlor@alaska.edu">Dr. Orion Lawlor</a> and the CS 601 class 2026-02-04.  It's public domain.</i>
</body></html>

